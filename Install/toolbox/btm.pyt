# -*- coding: utf-8 -*-

import os
import math
import sys
import re
import tempfile
import textwrap

import arcpy

# import our datatype conversion submodule
from datatype import datatype
dt = datatype.DataType()

# import our local directory so we can import internal modules
local_path = os.path.abspath(os.path.dirname(__file__))
scripts_path = os.path.join(local_path, "scripts")
sys.path.insert(0, scripts_path)

import scripts.utils as utils

# Check out any necessary licenses
arcpy.CheckOutExtension("Spatial")

# status messages
MSG_INVALID_GRID = "ESRI GRIDs must >= 13 characters and contain only " \
                   "letters, numbers and the underscore ('_') character."
MSG_INVALID_RADIUS = "Outer radius must exceed inner radius."


def raster_is_grid(raster_path):
    """Detect if the raster path is a file backed GRID file.
    Arguments:

        raster_path -- raster path name to test

    Returns:
        True if is a GRID file, False otherwise
    """
    is_grid = False
    ext = os.path.splitext(raster_path)[1]
    temp_dir = tempfile.gettempdir()
    if ext == "":
        # if the file has a GRID-like name but exists within a GDB, its a-ok
        if raster_path.lower().find(".gdb") == -1:
            is_grid = True
        # intermediate processing steps get generated by ModelBuilder
        # within the temp dir, skip these as they are only placeholder
        # names and work despite being invalid GRID names.
        if raster_path.lower().find(temp_dir) >= 0:
            is_grid = False
    return is_grid


def valid_grid_name(raster_path):
    """
    Validate ESRI GRID filenames. The file doesn't exist, so use
    naming to validate a potential name.
    Arguments:

        raster_path -- raster path name to validate

    Returns:
        valid raster boolean
    """

    valid = True
    # GRIDs are the default for any file without a trailing extension.
    if raster_is_grid(raster_path):
        if len(raster_path) > 128:
            valid = False
        else:
            grid_name = os.path.basename(raster_path)
            # Encode all the rules into a regular expression:
            #  - no longer than 13 characters
            #  - must start with a letter
            #  - only letters, numbers, and underscores.
            grid_regex = '^[A-Za-z]{1}[A-Za-z0-9_]{0,12}$'
            if re.match(grid_regex, grid_name) is None:
                valid = False

    return valid


def dedent(text, ending='\r\n'):
    text = text.replace('\n', ending)
    return textwrap.dedent(text)


def force_path():
    """
    Ensure Path environment is correctly initialized for our classes.
    Based on some research, it seems that while the standard imports
    come in fine, anything which alters the sys.path after initialization
    won't be respected by the subsequent `class` calls, and re-initialized
    to its initial state.
    """
    sys.path.insert(0, scripts_path)


class Toolbox(object):
    """ Benthic Terrain Modeler Python toolbox metaclass."""
    def __init__(self):
        self.label = u'Benthic Terrain Modeler'
        self.alias = 'btm'
        self.tools = [
            # Bathymetric Position Index
            broadscalebpi,      # broad scale
            finescalebpi,       # file scale
            standardizebpi,     # convert BPI values to standardized scores
            # Geomorphology Operations
            btmslope,           # compute slope
            statisticalaspect,  # break aspect up trigonometrically
            surfacetoplanar,    # compare surface area to planar area
            terrainruggedness,  # VRM, a measure of roughness
            # Summary Statistics
            depthstatistics,    # depth summary statistics
            scalecomparison,    # compare scales of analysis
            multiplescales,      # run tools at multiple scales
            # Create Classification of Zones/Types
            classifyterrain,    # run classification
            runfullmodel        # run all model steps
        ]


# tools below this section, one class per tool.
class broadscalebpi(object):
    """ Calculate Broad-scale Bathymetric Position Index (BPI).  """

    def __init__(self):
        force_path()
        self.label = u'Build Broad Scale BPI'
        self.description = dedent("""\
                The concept of bathymetric position is central to the benthic
                terrain classification process that is utilized by BTM.
                Bathymetric Position Index (BPI) is a measure of where a
                referenced location is relative to the locations surrounding it.
                BPI is derived from an input bathymetric data set and itself is
                a modification of the topographic position index (TPI) algorithm
                that is used in the terrestrial environment. The application of
                TPI to develop terrain classifications was explored and
                developed by Andrew Weiss during his study of terrestrial
                watersheds in Central Oregon (Weiss 2001). These applications
                can be carried into the benthic environment through BPI.

                A broad-scale BPI data set allows you to identify larger
                features within the benthic landscape.""")
        self.canRunInBackground = False
        # parameter names
        self.cols = ['bathy', 'inner', 'outer', 'scale_factor', 'output']

    def getParameterInfo(self):
        # Input_bathymetric_raster
        input_raster = arcpy.Parameter()
        input_raster.name = u'Input_bathymetric_raster'
        input_raster.displayName = u'Input bathymetric raster'
        input_raster.parameterType = 'Required'
        input_raster.direction = 'Input'
        input_raster.datatype = dt.format('Raster Layer')

        # Inner_radius
        inner_radius = arcpy.Parameter()
        inner_radius.name = u'Inner_radius'
        inner_radius.displayName = u'Inner radius'
        inner_radius.parameterType = 'Required'
        inner_radius.direction = 'Input'
        inner_radius.datatype = dt.format('Long')

        # Outer_radius
        outer_radius = arcpy.Parameter()
        outer_radius.name = u'Outer_radius'
        outer_radius.displayName = u'Outer radius'
        outer_radius.parameterType = 'Required'
        outer_radius.direction = 'Input'
        outer_radius.datatype = dt.format('Long')

        # Scale Factor
        scale_factor = arcpy.Parameter()
        scale_factor.name = 'Scale_factor'
        scale_factor.displayName = 'Scale factor'
        scale_factor.parameterType = 'Optional'
        scale_factor.datatype = dt.format('Long')
        scale_factor.enabled = False

        # Output_raster
        output_raster = arcpy.Parameter()
        output_raster.name = u'Output_raster'
        output_raster.displayName = u'Output raster'
        output_raster.parameterType = 'Required'
        output_raster.direction = 'Output'
        output_raster.datatype = dt.format('Raster Dataset')
        # output_raster.value = os.path.join(arcpy.env.workspace, 'broad_bpi')

        return [input_raster, inner_radius, outer_radius,
                scale_factor, output_raster]

    def isLicensed(self):
        return True

    def updateParameters(self, parameters):

        bathy = parameters[self.cols.index('bathy')].valueAsText
        outer_radius = parameters[self.cols.index('outer')].valueAsText
        scale_factor = parameters[self.cols.index('scale_factor')]

        if outer_radius is not None and bathy is not None:
            # get the cellsize of the input raster; assume same in X & Y
            cellsize = utils.raster_properties(bathy, "CELLSIZEY")
            # calculate our 'scale factor', modify the param
            scale_factor.value = math.ceil(cellsize * int(outer_radius) - 0.5)

        return

    def updateMessages(self, parameters):
        inner_radius = parameters[1].valueAsText
        outer_radius = parameters[2].valueAsText
        output = parameters[4].valueAsText

        if outer_radius is not None and inner_radius is not None:
            inner_rad = int(inner_radius)
            outer_rad = int(outer_radius)
            # test that the outer radius exceeds the inner radius.
            if inner_rad >= outer_rad:
                parameters[2].setErrorMessage(MSG_INVALID_RADIUS)

        # validate the output GRID name
        if output is not None:
            if not valid_grid_name(output):
                parameters[4].setErrorMessage(MSG_INVALID_GRID)

        return

    def execute(self, parameters, messages):
        # run related python script with selected input parameters
        import bpi
        bpi.main(
            bathy=parameters[0].valueAsText,
            inner_radius=parameters[1].valueAsText,
            outer_radius=parameters[2].valueAsText,
            out_raster=parameters[4].valueAsText,
            bpi_type='broad')


class finescalebpi(object):
    """ Calculate Fine-scale Bathymetric Position Index (BPI).  """

    def __init__(self):
        force_path()
        self.label = u'Build Fine Scale BPI'
        self.description = dedent("""\
                The concept of bathymetric position is central to the benthic
                terrain classification process that is utilized by the BTM.
                Bathymetric Position Index (BPI) is a measure of where a
                referenced location is relative to the locations surrounding it.
                BPI is derived from an input bathymetric data set and itself is
                a modification of the topographic position index (TPI) algorithm
                that is used in the terrestrial environment. The application of
                TPI to develop terrain classifications was explored and
                developed by Andrew Weiss during his study of terrestrial
                watersheds in Central Oregon (Weiss 2001). These applications
                can be carried into the benthic environment through BPI.

                A broad-scale BPI data set allows you to identify larger
                features within the benthic landscape.""")
        self.canRunInBackground = False
        # parameter names
        self.cols = ['bathy', 'inner', 'outer', 'scale_factor', 'output']

    def getParameterInfo(self):
        # Input_bathymetric_raster
        input_raster = arcpy.Parameter()
        input_raster.name = u'Input_bathymetric_raster'
        input_raster.displayName = u'Input bathymetric raster'
        input_raster.parameterType = 'Required'
        input_raster.direction = 'Input'
        input_raster.datatype = dt.format('Raster Layer')

        # Inner_radius
        inner_radius = arcpy.Parameter()
        inner_radius.name = u'Inner_radius'
        inner_radius.displayName = u'Inner radius'
        inner_radius.parameterType = 'Required'
        inner_radius.direction = 'Input'
        inner_radius.datatype = dt.format('Long')

        # Outer_radius
        outer_radius = arcpy.Parameter()
        outer_radius.name = u'Outer_radius'
        outer_radius.displayName = u'Outer radius'
        outer_radius.parameterType = 'Required'
        outer_radius.direction = 'Input'
        outer_radius.datatype = dt.format('Long')

        # Scale Factor
        scale_factor = arcpy.Parameter()
        scale_factor.name = 'Scale_factor'
        scale_factor.displayName = 'Scale factor'
        scale_factor.parameterType = 'Optional'
        scale_factor.datatype = dt.format('Long')
        scale_factor.enabled = False

        # Output_raster
        output_raster = arcpy.Parameter()
        output_raster.name = u'Output_raster'
        output_raster.displayName = u'Output raster'
        output_raster.parameterType = 'Required'
        output_raster.direction = 'Output'
        output_raster.datatype = dt.format('Raster Dataset')

        # TODO: implement mutlvalue support
        multivalue = arcpy.Parameter()
        multivalue.name = u'Test multi'
        multivalue.displayName = u'Test multi'
        multivalue.parameterType = 'Optional'
        multivalue.direction = 'Input'
        multivalue.datatype = dt.format('Any Value')

        return [input_raster, inner_radius, outer_radius,
                scale_factor, output_raster]

    def isLicensed(self):
        return True

    def updateParameters(self, parameters):

        bathy = parameters[self.cols.index('bathy')].valueAsText
        outer_radius = parameters[self.cols.index('outer')].valueAsText
        scale_factor = parameters[self.cols.index('scale_factor')]

        if outer_radius is not None and bathy is not None:
            # get the cellsize of the input raster; assume same in X & Y
            cellsize = utils.raster_properties(bathy, "CELLSIZEY")
            # calculate our 'scale factor', modify the param
            scale_factor.value = math.ceil(cellsize * int(outer_radius) - 0.5)

        return

    def updateMessages(self, parameters):
        inner_radius = parameters[1].valueAsText
        outer_radius = parameters[2].valueAsText
        output = parameters[4].valueAsText
        if outer_radius is not None and inner_radius is not None:
            inner_rad = int(inner_radius)
            outer_rad = int(outer_radius)
            # test that the outer radius exceeds the inner radius.
            if inner_rad >= outer_rad:
                parameters[2].setErrorMessage(MSG_INVALID_RADIUS)

        # validate the output GRID name
        if output is not None:
            if not valid_grid_name(output):
                parameters[4].setErrorMessage(MSG_INVALID_GRID)

        return

    def execute(self, parameters, messages):
        # run related python script with selected input parameters
        import bpi
        bpi.main(
            bathy=parameters[0].valueAsText,
            inner_radius=parameters[1].valueAsText,
            outer_radius=parameters[2].valueAsText,
            out_raster=parameters[4].valueAsText,
            bpi_type='fine')


class standardizebpi(object):
    """
    Standardize BPI rasters.
    """

    def __init__(self):
        force_path()
        self.label = u'Standardize BPIs'
        self.canRunInBackground = False
        self.cols = [
            'broad_input', 'broad_mean', 'broad_stddev', 'broad_output',
            'fine_input', 'fine_mean', 'fine_stddev', 'fine_output'
        ]

    def getParameterInfo(self):
        # Input_BPI_raster
        broad_raster = arcpy.Parameter()
        broad_raster.name = u'Broad_BPI_raster'
        broad_raster.displayName = u'Broad BPI raster'
        broad_raster.parameterType = 'Required'
        broad_raster.direction = 'Input'
        broad_raster.datatype = dt.format('Raster Layer')

        # dervied statistics
        broad_mean = arcpy.Parameter()
        broad_mean.name = 'Broad_BPI_Mean'
        broad_mean.displayName = 'Broad BPI Mean'
        broad_mean.parameterType = 'Required'
        broad_mean.datatype = dt.format('Double')
        broad_mean.enabled = False
        broad_mean.value = 0

        broad_stddev = arcpy.Parameter()
        broad_stddev.name = 'Broad_BPI_Standard_deviation'
        broad_stddev.displayName = 'Broad BPI Standard Deviation'
        broad_stddev.parameterType = 'Required'
        broad_stddev.datatype = dt.format('Double')
        broad_stddev.enabled = False
        broad_stddev.value = 0

        # Output_raster
        broad_std_output = arcpy.Parameter()
        broad_std_output.name = u'Output_broad_raster'
        broad_std_output.displayName = u'Output Standardized Broad BPI raster'
        broad_std_output.parameterType = 'Required'
        broad_std_output.direction = 'Output'
        broad_std_output.datatype = dt.format('Raster Dataset')

        # Input_BPI_raster
        fine_raster = arcpy.Parameter()
        fine_raster.name = u'Fine_BPI_raster'
        fine_raster.displayName = u'Fine BPI raster'
        fine_raster.parameterType = 'Required'
        fine_raster.direction = 'Input'
        fine_raster.datatype = dt.format('Raster Layer')

        # dervied statistics
        fine_mean = arcpy.Parameter()
        fine_mean.name = 'Fine_BPI_Mean'
        fine_mean.displayName = 'Fine BPI Mean'
        fine_mean.parameterType = 'Required'
        fine_mean.datatype = dt.format('Double')
        fine_mean.enabled = False
        fine_mean.value = 0

        fine_stddev = arcpy.Parameter()
        fine_stddev.name = 'Fine_BPI_Standard_deviation'
        fine_stddev.displayName = 'Fine BPI Standard Deviation'
        fine_stddev.parameterType = 'Required'
        fine_stddev.datatype = dt.format('Double')
        fine_stddev.enabled = False
        fine_stddev.value = 0

        # Output_raster
        fine_std_output = arcpy.Parameter()
        fine_std_output.name = u'Output_fine_raster'
        fine_std_output.displayName = u'Output Standardized Fine BPI raster'
        fine_std_output.parameterType = 'Required'
        fine_std_output.direction = 'Output'
        fine_std_output.datatype = dt.format('Raster Dataset')

        return [broad_raster, broad_mean, broad_stddev, broad_std_output,
                fine_raster, fine_mean, fine_stddev, fine_std_output]

    def isLicensed(self):
        return True

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):

        for label in ['broad', 'fine']:
            input_raster = parameters[self.cols.index(label + '_input')].valueAsText
            if input_raster is not None:
                (mean, stddev) = self.getRasterStats(input_raster)
                if mean is not None:
                    # try modifying our variables
                    parameters[self.cols.index(label + '_mean')].value = mean
                    parameters[self.cols.index(label + '_stddev')].value = stddev

            # Validate GRID outputs.
            out_param = self.cols.index(label + '_output')
            output_raster = parameters[out_param].valueAsText
            if output_raster is not None:
                if not valid_grid_name(output_raster):
                    parameters[out_param].setErrorMessage(MSG_INVALID_GRID)
        return

    def getRasterStats(self, input_raster=None):
        result = (None, None)
        if input_raster is not None:
            try:
                result = (utils.raster_properties(input_raster, 'MEAN'),
                          utils.raster_properties(input_raster, 'STD'))
            except:
                # check for raster existence, when running as a model the 'result'
                # may be set, but not actually exist, causing these steps to fail.
                pass
                # f.write("\n\nFULLEXEC: {}\n".format(sys.exc_info()))
        return result

    def execute(self, parameters, messages):
        # run related python script with selected input parameters
        import standardize_bpi_grids
        # run for broad raster...
        standardize_bpi_grids.main(
            bpi_raster=parameters[0].valueAsText,
            out_raster=parameters[3].valueAsText)
        #  ...and again for fine raster.
        standardize_bpi_grids.main(
            bpi_raster=parameters[4].valueAsText,
            out_raster=parameters[7].valueAsText)


class statisticalaspect(object):
    """ Calculate statistical aspect, uses standard SA function internally."""
    def __init__(self):
        force_path()
        self.label = u'Calculate Statistical Aspect'
        self.canRunInBackground = False

    def getParameterInfo(self):
        # Input_bathymetric_raster
        input_raster = arcpy.Parameter()
        input_raster.name = u'Input_bathymetric_raster'
        input_raster.displayName = u'Input bathymetric raster'
        input_raster.parameterType = 'Required'
        input_raster.direction = 'Input'
        input_raster.datatype = dt.format('Raster Layer')

        # Output Sin raster
        output_sin_raster = arcpy.Parameter()
        output_sin_raster.name = u'Output_sin_raster'
        output_sin_raster.displayName = u'Output Sin(Aspect) raster'
        output_sin_raster.parameterType = 'Required'
        output_sin_raster.direction = 'Output'
        output_sin_raster.datatype = dt.format('Raster Dataset')

        # Output Cos raster
        output_cos_raster = arcpy.Parameter()
        output_cos_raster.name = u'Output_cos_raster'
        output_cos_raster.displayName = u'Output Cos(Aspect) raster'
        output_cos_raster.parameterType = 'Required'
        output_cos_raster.direction = 'Output'
        output_cos_raster.datatype = dt.format('Raster Dataset')

        return [input_raster, output_sin_raster, output_cos_raster]

    def isLicensed(self):
        return True

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        output_sin = parameters[1].valueAsText
        output_cos = parameters[2].valueAsText

        # validate the output GRID name
        if output_sin is not None:
            if not valid_grid_name(output_sin):
                parameters[1].setErrorMessage(MSG_INVALID_GRID)

        if output_cos is not None:
            if not valid_grid_name(output_cos):
                parameters[2].setErrorMessage(MSG_INVALID_GRID)
        return

    def execute(self, parameters, messages):
        # run related python script with selected input parameters
        import aspect
        aspect.main(
            bathy=parameters[0].valueAsText,
            out_sin_raster=parameters[1].valueAsText,
            out_cos_raster=parameters[2].valueAsText)


class btmslope(object):
    """ Calculate slope, uses standard SA function internally."""
    def __init__(self):
        force_path()
        self.label = u'Calculate Slope'
        self.canRunInBackground = False

    def getParameterInfo(self):
        # Input_bathymetric_raster
        input_raster = arcpy.Parameter()
        input_raster.name = u'Input_bathymetric_raster'
        input_raster.displayName = u'Input bathymetric raster'
        input_raster.parameterType = 'Required'
        input_raster.direction = 'Input'
        input_raster.datatype = dt.format('Raster Layer')

        # Output_raster
        output_raster = arcpy.Parameter()
        output_raster.name = u'Output_raster'
        output_raster.displayName = u'Output raster'
        output_raster.parameterType = 'Required'
        output_raster.direction = 'Output'
        output_raster.datatype = dt.format('Raster Dataset')

        return [input_raster, output_raster]

    def isLicensed(self):
        return True

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        output = parameters[1].valueAsText
        # validate the output GRID name
        if output is not None:
            if not valid_grid_name(output):
                parameters[1].setErrorMessage(MSG_INVALID_GRID)

        return

    def execute(self, parameters, messages):
        # run related python script with selected input parameters
        import slope
        slope.main(
            bathy=parameters[0].valueAsText,
            out_raster=parameters[1].valueAsText)


class classifyterrain(object):
    """ Classify Benthic Terrain based on classification dictionary. """
    def __init__(self):
        force_path()
        self.label = u'Classify Benthic Terrain'
        self.canRunInBackground = False

    def getParameterInfo(self):
        # Classification Dictionary
        class_dict = arcpy.Parameter()
        class_dict.name = u'Classification_dictionary'
        class_dict.displayName = u'Classification dictionary'
        class_dict.direction = 'Input'
        class_dict.datatype = dt.format('File')
        class_dict.parameterType = 'Required'

        # classification dictionary must be of the types we parse.
        class_dict.filter.list = ['csv', 'xls', 'xlsx', 'xml']

        # Standardized broad-scale BPI raster
        broad_bpi_std = arcpy.Parameter()
        broad_bpi_std.name = u'Standardized_broad-scale_BPI_raster'
        broad_bpi_std.displayName = u'Standardized broad-scale BPI raster'
        broad_bpi_std.parameterType = 'Required'
        broad_bpi_std.direction = 'Input'
        broad_bpi_std.datatype = dt.format('Raster Layer')

        # Standardized fine-scale BPI raster
        fine_bpi_std = arcpy.Parameter()
        fine_bpi_std.name = u'Standardized_fine-scale_BPI_raster'
        fine_bpi_std.displayName = u'Standardized fine-scale BPI raster'
        fine_bpi_std.parameterType = 'Required'
        fine_bpi_std.direction = 'Input'
        fine_bpi_std.datatype = dt.format('Raster Layer')

        # Slope_raster
        slope = arcpy.Parameter()
        slope.name = u'Slope_raster'
        slope.displayName = u'Slope raster'
        slope.parameterType = 'Required'
        slope.direction = 'Input'
        slope.datatype = dt.format('Raster Layer')

        # Bathymetry raster
        bathy = arcpy.Parameter()
        bathy.name = u'Bathymetry_raster'
        bathy.displayName = u'Bathymetry raster'
        bathy.parameterType = 'Required'
        bathy.direction = 'Input'
        bathy.datatype = dt.format('Raster Layer')

        # Output_raster
        zones_raster = arcpy.Parameter()
        zones_raster.name = u'Output_zones_raster'
        zones_raster.displayName = u'Output Zones Raster'
        zones_raster.parameterType = 'Required'
        zones_raster.direction = 'Output.'
        zones_raster.datatype = dt.format('Raster Dataset')
        return [class_dict, broad_bpi_std, fine_bpi_std, slope, bathy, zones_raster]

    def isLicensed(self):
        return True

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        output = parameters[5].valueAsText
        # validate the output GRID name
        if output is not None:
            if not valid_grid_name(output):
                parameters[5].setErrorMessage(MSG_INVALID_GRID)
        return

    def execute(self, parameters, messages):
        import classify
        classify.main(
            classification_file=parameters[0].valueAsText,
            bpi_broad_std=parameters[1].valueAsText,
            bpi_fine_std=parameters[2].valueAsText,
            slope=parameters[3].valueAsText,
            bathy=parameters[4].valueAsText,
            out_raster=parameters[5].valueAsText)


class runfullmodel(object):
    """ Run all model steps to classify benthic terrain. """

    def __init__(self):
        force_path()
        self.label = u'Run All Model Steps'
        self.canRunInBackground = False
        self.cols = [
            'out_workspace', 'bathy', 'broad_bpi_inner', 'broad_bpi_outer',
            'fine_bpi_inner', 'fine_bpi_outer', 'class_dict', 'zones_raster'
        ]

    def getParameterInfo(self):
        # Output_Workspace

        out_workspace = arcpy.Parameter()
        out_workspace.name = u'Output_Workspace'
        out_workspace.displayName = u'Output Workspace'
        out_workspace.parameterType = 'Required'
        out_workspace.direction = 'Input'
        out_workspace.datatype = dt.format('Workspace')

        # Bathymetry raster
        bathy = arcpy.Parameter()
        bathy.name = u'Bathymetry_raster'
        bathy.displayName = u'Bathymetry raster'
        bathy.parameterType = 'Required'
        bathy.direction = 'Input'
        bathy.datatype = dt.format('Raster Layer')

        # Broad-scale BPI raster inner radius
        broad_bpi_inner = arcpy.Parameter()
        broad_bpi_inner.name = u'broad-scale_BPI_inner_radius'
        broad_bpi_inner.displayName = u'broad-scale BPI inner radius'
        broad_bpi_inner.parameterType = 'Required'
        broad_bpi_inner.direction = 'Input'
        broad_bpi_inner.datatype = dt.format('Long')

        # Broad-scale BPI raster inner radius
        broad_bpi_outer = arcpy.Parameter()
        broad_bpi_outer.name = u'broad-scale_BPI_outer_radius'
        broad_bpi_outer.displayName = u'broad-scale BPI outer radius'
        broad_bpi_outer.parameterType = 'Required'
        broad_bpi_outer.direction = 'Input'
        broad_bpi_outer.datatype = dt.format('Long')

        # Fine-scale BPI raster inner radius
        fine_bpi_inner = arcpy.Parameter()
        fine_bpi_inner.name = u'fine-scale_BPI_inner_radius'
        fine_bpi_inner.displayName = u'fine-scale BPI inner radius'
        fine_bpi_inner.parameterType = 'Required'
        fine_bpi_inner.direction = 'Input'
        fine_bpi_inner.datatype = dt.format('Long')

        # Fine-scale BPI raster inner radius
        fine_bpi_outer = arcpy.Parameter()
        fine_bpi_outer.name = u'fine-scale_BPI_outer_radius'
        fine_bpi_outer.displayName = u'fine-scale BPI outer radius'
        fine_bpi_outer.parameterType = 'Required'
        fine_bpi_outer.direction = 'Input'
        fine_bpi_outer.datatype = dt.format('Long')

        # Classification Dictionary
        class_dict = arcpy.Parameter()
        class_dict.name = u'Classification_dictionary'
        class_dict.displayName = u'Classification dictionary'
        class_dict.direction = 'Input'
        class_dict.datatype = dt.format('File')
        class_dict.parameterType = 'Required'

        # classification dictionary must be of the types we parse.
        class_dict.filter.list = ['csv', 'xls', 'xlsx', 'xml']

        # Output_raster
        zones_raster = arcpy.Parameter()
        zones_raster.name = u'Output_zones_raster'
        zones_raster.displayName = u'Output Zones Raster'
        zones_raster.parameterType = 'Required'
        zones_raster.direction = 'Output'
        # was raster dataset, but no way to control path then...
        zones_raster.datatype = dt.format('String')

        return [out_workspace, bathy, broad_bpi_inner, broad_bpi_outer,
                fine_bpi_inner, fine_bpi_outer, class_dict, zones_raster]

    def isLicensed(self):
        return True

    def validateRadius(self, inner_param, outer_param):
        is_valid = True
        inner_val = inner_param.valueAsText
        outer_val = outer_param.valueAsText

        if inner_val is not None and outer_val is not None:
            inner_rad = int(inner_val)
            outer_rad = int(outer_val)
            # test that the outer radius exceeds the inner radius.
            if inner_rad >= outer_rad:
                is_valid = False
        return is_valid

    def updateParameters(self, parameters):
        out_workspace = parameters[self.cols.index('out_workspace')].valueAsText
        zones_raster = parameters[self.cols.index('zones_raster')].valueAsText

        # TODO: make this work so that if they update the output_zones,
        #       we respect it.
        if out_workspace is not None and zones_raster is None:
            parameters[self.cols.index('zones_raster')].value = \
                os.path.join(out_workspace, "output_zones")
        return

    def updateMessages(self, parameters):
        broad_inner = parameters[self.cols.index('broad_bpi_inner')]
        broad_outer = parameters[self.cols.index('broad_bpi_outer')]
        if not self.validateRadius(broad_inner, broad_outer):
            broad_inner.setErrorMessage(MSG_INVALID_RADIUS)

        fine_inner = parameters[self.cols.index('fine_bpi_inner')]
        fine_outer = parameters[self.cols.index('fine_bpi_outer')]
        if not self.validateRadius(fine_inner, fine_outer):
            fine_inner.setErrorMessage(MSG_INVALID_RADIUS)

        return

    def execute(self, parameters, messages):
        import btm_model
        btm_model.main(
            out_workspace=parameters[0].valueAsText,
            input_bathymetry=parameters[1].valueAsText,
            broad_bpi_inner_radius=parameters[2].valueAsText,
            broad_bpi_outer_radius=parameters[3].valueAsText,
            fine_bpi_inner_radius=parameters[4].valueAsText,
            fine_bpi_outer_radius=parameters[5].valueAsText,
            classification_dict=parameters[6].valueAsText,
            output_zones=parameters[7].valueAsText)


class structureclassification(object):
    """Classify benthic terrain based on structures."""
    def __init__(self):
        force_path()
        self.label = u'Structure Classification Builder'
        self.canRunInBackground = False

    def getParameterInfo(self):
        # Standardized_broad-scale_BPI_raster
        broad_bpi = arcpy.Parameter()
        broad_bpi.name = u'Standardized_broad-scale_BPI_raster'
        broad_bpi.displayName = u'Standardized broad-scale BPI raster'
        broad_bpi.parameterType = 'Required'
        broad_bpi.direction = 'Input'
        broad_bpi.datatype = dt.format('Raster Layer')

        # Broad-scale_BPI_standard_deviation_break
        broad_stddev = arcpy.Parameter()
        broad_stddev.name = u'Broad-scale_BPI_standard_deviation_break'
        broad_stddev.displayName = u'Broad-scale BPI standard deviation break'
        broad_stddev.parameterType = 'Required'
        broad_stddev.direction = 'Input'
        broad_stddev.datatype = dt.format('Double')

        # Standardized_fine-scale_BPI_raster
        fine_bpi = arcpy.Parameter()
        fine_bpi.name = u'Standardized_fine-scale_BPI_raster'
        fine_bpi.displayName = u'Standardized fine-scale BPI raster'
        fine_bpi.parameterType = 'Required'
        fine_bpi.direction = 'Input'
        fine_bpi.datatype = dt.format('Raster Layer')

        # Fine-scale_BPI_standard_deviation_break
        fine_stddev = arcpy.Parameter()
        fine_stddev.name = u'Fine-scale_BPI_standard_deviation_break'
        fine_stddev.displayName = u'Fine-scale BPI standard deviation break'
        fine_stddev.parameterType = 'Required'
        fine_stddev.direction = 'Input'
        fine_stddev.datatype = dt.format('Double')

        # Slope_raster
        slope = arcpy.Parameter()
        slope.name = u'Slope_raster'
        slope.displayName = u'Slope raster'
        slope.parameterType = 'Required'
        slope.direction = 'Input'
        slope.datatype = dt.format('Raster Layer')

        # Slope_value__in_degrees__indicating_a_gentle_slope
        slope_gentle = arcpy.Parameter()
        slope_gentle.name = u'Slope_value__in_degrees__indicating_a_gentle_slope'
        slope_gentle.displayName = \
            u'Slope value (in degrees) indicating a gentle slope'
        slope_gentle.parameterType = 'Required'
        slope_gentle.direction = 'Input'
        slope_gentle.datatype = dt.format('Double')

        # Slope_value__in_degrees__indicating_a_steep_slope
        slope_steep = arcpy.Parameter()
        slope_steep.name = u'Slope_value__in_degrees__indicating_a_steep_slope'
        slope_steep.displayName = \
            u'Slope value (in degrees) indicating a steep slope'
        slope_steep.parameterType = 'Required'
        slope_steep.direction = 'Input'
        slope_steep.datatype = dt.format('Double')

        # Bathymetric_raster
        bathy = arcpy.Parameter()
        bathy.name = u'Bathymetric_raster'
        bathy.displayName = u'Bathymetric raster'
        bathy.parameterType = 'Required'
        bathy.direction = 'Input'
        bathy.datatype = dt.format('Raster Layer')

        # Depth_indicating_break_between_shelf_and_broad_flat
        broad_vs_flat = arcpy.Parameter()
        broad_vs_flat.name = u'Depth_indicating_break_between_shelf_and_broad_flat'
        broad_vs_flat.displayName = \
            u'Depth indicating break between shelf and broad flat'
        broad_vs_flat.parameterType = 'Required'
        broad_vs_flat.direction = 'Input'
        broad_vs_flat.datatype = dt.format('Double')

        # Output_raster
        output_raster = arcpy.Parameter()
        output_raster.name = u'Output_raster'
        output_raster.displayName = u'Output raster'
        output_raster.parameterType = 'Required'
        output_raster.direction = 'Output'
        output_raster.datatype = dt.format('Raster Dataset')

        return [broad_bpi, broad_stddev, fine_bpi, fine_stddev, slope, slope_gentle,
                slope_steep, bathy, broad_vs_flat, output_raster]

    def isLicensed(self):
        return True

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        return

    def execute(self, parameters, messages):
        pass


class surfacetoplanar(object):
    """Compute Surface Area to Planar Area (ratio)."""

    def __init__(self):
        force_path()
        self.label = u'Surface Area to Planar Area'
        self.description = dedent(
            """Measure terrain ruggedness by calculating the ratio
            between the surface area and the planar area, as described
            in Jenness 2002.""")
        self.canRunInBackground = False

    def getParameterInfo(self):
        # Bathymetry_Raster
        input_raster = arcpy.Parameter()
        input_raster.name = u'Bathymetry_Raster'
        input_raster.displayName = u'Bathymetry Raster'
        input_raster.parameterType = 'Required'
        input_raster.direction = 'Input'
        input_raster.datatype = dt.format('Raster Layer')

        # Output_Raster
        output_raster = arcpy.Parameter()
        output_raster.name = u'Output_Raster'
        output_raster.displayName = u'Output Raster'
        output_raster.parameterType = 'Required'
        output_raster.direction = 'Output'
        output_raster.datatype = dt.format('Raster Dataset')

        #ACR Correction
        acr_correction = arcpy.Parameter()
        acr_correction.name = u'ACR_Correction'
        acr_correction.displayName = u'Correct Planar Area for Slope'
        acr_correction.parameterType = 'Optional'
        acr_correction.direction = 'Input'
        acr_correction.datatype = dt.format('Boolean')
        acr_correction.value = 'True'

        # Area_Raster
        area_raster = arcpy.Parameter()
        area_raster.name = u'Area_Raster'
        area_raster.displayName = u'Area Raster'
        area_raster.parameterType = 'Optional'
        area_raster.direction = 'Output'
        area_raster.datatype = dt.format('Raster Dataset')

        return [input_raster, output_raster, acr_correction, area_raster]

    def isLicensed(self):
        return True

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        output = parameters[1].valueAsText
        # validate the output GRID name
        if output is not None:
            if not valid_grid_name(output):
                parameters[1].setErrorMessage(MSG_INVALID_GRID)
        return

    def execute(self, parameters, messages):
        # run related python script with selected input parameters
        import surface_area_to_planar_area
        reload(surface_area_to_planar_area)
        surface_area_to_planar_area.main(
            in_raster=parameters[0].valueAsText,
            out_raster=parameters[1].valueAsText,
            acr_correction=parameters[2].valueAsText,
            area_raster=parameters[3].valueAsText)


class terrainruggedness(object):
    """Compute Terrain Ruggedness Measure (VRM)."""

    def __init__(self):
        force_path()
        self.label = u'Terrain Ruggedness (VRM)'
        self.description = dedent("""\
                Measure terrain ruggedness by calculating the vector ruggedness
                measure (VRM), as described in Sappington et al, 2007.""")
        self.canRunInBackground = False

    def getParameterInfo(self):
        # Bathymetry_Raster
        input_raster = arcpy.Parameter()
        input_raster.name = u'Bathymetry_Raster'
        input_raster.displayName = u'Bathymetry Raster'
        input_raster.parameterType = 'Required'
        input_raster.direction = 'Input'
        input_raster.datatype = dt.format('Raster Layer')

        # Neighborhood_Size
        neighborhood = arcpy.Parameter()
        neighborhood.name = u'Neighborhood_Size'
        neighborhood.displayName = u'Neighborhood Size'
        neighborhood.parameterType = 'Required'
        neighborhood.direction = 'Input'
        neighborhood.datatype = dt.format('Long')

        # Output_Raster
        output_raster = arcpy.Parameter()
        output_raster.name = u'Output_Raster'
        output_raster.displayName = u'Output Raster'
        output_raster.parameterType = 'Required'
        output_raster.direction = 'Output'
        output_raster.datatype = dt.format('Raster Dataset')

        return [input_raster, neighborhood, output_raster]

    def isLicensed(self):
        return True

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        output = parameters[2].valueAsText
        # validate the output GRID name
        if output is not None:
            if not valid_grid_name(output):
                parameters[2].setErrorMessage(MSG_INVALID_GRID)

        n_size = parameters[1].valueAsText
        if n_size is not None:
            if float(n_size) % 2 == 0:
                parameters[1].setWarningMessage(
                    "If an even neighborhood size is used, neighborhood"\
                    " coordinates will be computed using truncation."\
                    " Use an odd neighborhood size to avoid unexpected results.")

        return

    def execute(self, parameters, messages):
        # run related python script with selected input parameters
        import ruggedness
        ruggedness.main(
            in_raster=parameters[0].valueAsText,
            neighborhood_size=parameters[1].valueAsText,
            out_raster=parameters[2].valueAsText)


class depthstatistics(object):
    """ Depth Statistics computes a suite of summary statistics. This initial
        version works on a fixed window size, but user feedback has indicated
        a more general version which supported multiple window sizes,
        including vector-based ones, would be preferable.

        Also, this current version uses focal tools, but could be computed in
        one pass using numpy instead, but memory considerations would need
        to be taken into account, or the algorithm would need to operate on
        blocks within the data. see 'rugosity.py' script an example of this
        approach, can use NumPyArrayToRaster and vice versa.
    """

    def __init__(self):
        force_path()
        self.label = u'Depth Statistics'
        self.canRunInBackground = False

    def getParameterInfo(self):
        # Bathymetry_Raster
        input_raster = arcpy.Parameter()
        input_raster.name = u'Bathymetry_Raster'
        input_raster.displayName = u'Bathymetry Raster'
        input_raster.parameterType = 'Required'
        input_raster.direction = 'Input'
        input_raster.datatype = dt.format('Raster Layer')

        # Neighborhood_Size
        neighborhood = arcpy.Parameter()
        neighborhood.name = u'Neighborhood_Size'
        neighborhood.displayName = u'Neighborhood Size'
        neighborhood.parameterType = 'Required'
        neighborhood.direction = 'Input'
        neighborhood.datatype = dt.format('Long')

        # Output_Workspace
        out_workspace = arcpy.Parameter()
        out_workspace.name = u'Output_Workspace'
        out_workspace.displayName = u'Output Workspace'
        out_workspace.parameterType = 'Required'
        out_workspace.direction = 'Input'
        out_workspace.datatype = dt.format('Workspace')

        # Statistics to Compute
        statistics = arcpy.Parameter()
        statistics.name = u'Statistics_Computed'
        statistics.displayName = u'Statistics to Compute'
        statistics.parameterType = 'Required'
        statistics.direction = 'Input'
        statistics.datatype = dt.format('String')
        statistics.multiValue = True
        statistics.filter.list = ['Mean Depth', 'Variance', 'Standard Deviation']

        return [input_raster, neighborhood, out_workspace, statistics]

    def isLicensed(self):
        return True

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        return

    def execute(self, parameters, messages):
        # run related python script with selected input parameters
        import depth_statistics
        depth_statistics.main(
            in_raster=parameters[0].valueAsText,
            neighborhood_size=parameters[1].valueAsText,
            out_workspace=parameters[2].valueAsText,
            out_stats_raw=parameters[3].valueAsText)


class scalecomparison(object):
    """ Create a visual aid for easy comparison between statistics
        computed at different scales """
    def __init__(self):
        force_path()
        self.label = u'Compare Scales of Analysis'
        self.canRunInBackground = False

    def getParameterInfo(self):

        # Bathymetry raster
        bathy = arcpy.Parameter()
        bathy.name = u'Bathymetry_raster'
        bathy.displayName = u'Bathymetry raster'
        bathy.parameterType = 'Required'
        bathy.direction = 'Input'
        bathy.datatype = dt.format('Raster Layer')

        # Image Filter
        imgfilter = arcpy.Parameter()
        imgfilter.name = u'Filter'
        imgfilter.displayName = u'Filter'
        imgfilter.parameterType = 'Required'
        imgfilter.direction = 'Input'
        imgfilter.datatype = dt.format('String')
        imgfilter.value = 'Median'
        imgfilter.filter.list = ['Median', 'Minimum', 'Maximum', 'Percentile']

        # Percentile
        percentile = arcpy.Parameter()
        percentile.name = u'Percentile'
        percentile.displayName = u'Percentile'
        percentile.parameterType = 'Optional'
        percentile.value = None
        percentile.direction = 'Input'
        percentile.datatype = dt.format('Long')
        percentile.enabled = False

        # Minimum Neighborhood_Size
        minneighborhood = arcpy.Parameter()
        minneighborhood.name = u'Minimum Neighborhood_Size'
        minneighborhood.displayName = u'Minimum Neighborhood Size'
        minneighborhood.parameterType = 'Required'
        minneighborhood.direction = 'Input'
        minneighborhood.datatype = dt.format('Long')

        # Maximum Neighborhood_Size
        maxneighborhood = arcpy.Parameter()
        maxneighborhood.name = u'Maximum Neighborhood_Size'
        maxneighborhood.displayName = u'Maximum Neighborhood Size'
        maxneighborhood.parameterType = 'Required'
        maxneighborhood.direction = 'Input'
        maxneighborhood.datatype = dt.format('Long')

        # Output File Name
        out_file = arcpy.Parameter()
        out_file.name = u'Output Filename'
        out_file.displayName = u'Output Filename'
        out_file.direction = 'Output'
        out_file.datatype = dt.format('File')
        out_file.parameterType = 'Required'
        out_file.filter.list = ['png', 'pdf', 'ps', 'svg']

        return [bathy, imgfilter, percentile, minneighborhood,
                maxneighborhood, out_file]

    def updateParameters(self, parameters):
        if parameters[1].valueAsText.lower() == 'percentile':
            parameters[2].enabled = True
            parameters[2].parameterType = 'Required'
        else:
            parameters[2].enabled = False
            parameters[2].parameterType = 'Optional'
        return

    def updateMessages(self, parameters):
        return

    def execute(self, parameters, messages):
        import scale_comparison
        scale_comparison.main(
            in_raster=parameters[0].valueAsText, img_filter=parameters[1].valueAsText,
            percentile=parameters[2].valueAsText, min_nbhs=parameters[3].valueAsText,
            max_nbhs=parameters[4].valueAsText, out_file=parameters[5].valueAsText)


class multiplescales(object):
    """ Calculate metrics at multiple scales. """

    def __init__(self):
        force_path()
        self.label = u'Calculate Metrics At Multiple Scales'
        self.canRunInBackground = False

    def getParameterInfo(self):

        # Bathymetry raster
        bathy = arcpy.Parameter()
        bathy.name = u'Bathymetry_raster'
        bathy.displayName = u'Bathymetry raster'
        bathy.parameterType = 'Required'
        bathy.direction = 'Input'
        bathy.datatype = dt.format('Raster Layer')

        # Neighborhood_Sizes
        nbh_sizes = arcpy.Parameter()
        nbh_sizes.name = u'Neighborhood_Size'
        nbh_sizes.displayName = u'Neighborhood Size'
        nbh_sizes.parameterType = 'Required'
        nbh_sizes.direction = 'Input'
        nbh_sizes.datatype = dt.format('Long')
        nbh_sizes.multiValue = True

        # Metrics to Compute
        metrics = arcpy.Parameter()
        metrics.name = u'Metrics_Computed'
        metrics.displayName = u'Metrics to Compute'
        metrics.parameterType = 'Required'
        metrics.direction = 'Input'
        metrics.datatype = dt.format('String')
        metrics.multiValue = True
        metrics.filter.list = ['Mean Depth', 'Variance', 'Standard Deviation',
                               'Terrain Ruggedness (VRM)']

        # Output Workspace
        out_workspace = arcpy.Parameter()
        out_workspace.name = u'Output_Workspace'
        out_workspace.displayName = u'Output Workspace'
        out_workspace.parameterType = 'Required'
        out_workspace.direction = 'Input'
        out_workspace.datatype = dt.format('Workspace')

        return [bathy, nbh_sizes, metrics, out_workspace]

    def isLicensed(self):
        return True

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        return

    def execute(self, parameters, messages):
        import depth_statistics
        import ruggedness

        nbh_lst = parameters[1].valueAsText.split(";")
        metrics_lst = parameters[2].valueAsText.replace("'", '').split(";")
        stats_set = set(['Mean Depth', 'Standard Deviation', 'Variance'])
        vrm_set = set(['Terrain Ruggedness (VRM)'])

        for each in nbh_lst:
            utils.msg("Computing metrics for neighborhood size {}...".format(each))
            if stats_set.intersection(metrics_lst):
                depth_statistics.main(in_raster=parameters[0].valueAsText,
                                      neighborhood_size=each,
                                      out_workspace=parameters[3].valueAsText,
                                      out_stats_raw=parameters[2].valueAsText)
            if vrm_set.intersection(metrics_lst):
                n_label = "{:03d}".format(int(each))
                out_file = "{}\\ruggedness_{}.tif".format(parameters[3].valueAsText, n_label)
                ruggedness.main(in_raster=parameters[0].valueAsText,
                                neighborhood_size=each, out_raster=out_file)
        return