# -*- coding: utf-8 -*-

import os
import math
import sys
import json
import re
import tempfile
import textwrap

import arcpy

# import our datatype conversion submodule
from datatype import datatype
dt = datatype.DataType()

import scripts
from scripts import utils

# Check out any necessary licenses
arcpy.CheckOutExtension("Spatial")

# status messages
MSG_INVALID_GRID = "ESRI GRIDs must >= 13 characters and contain only " \
                   "letters, numbers and the underscore ('_') character."
MSG_INVALID_RADIUS = "Outer radius must exceed inner radius."


def raster_is_grid(raster_path):
    """Detect if the raster path is a file backed GRID file.
    Arguments:

        raster_path -- raster path name to test

    Returns:
        True if is a GRID file, False otherwise
    """
    is_grid = False
    ext = os.path.splitext(raster_path)[1]
    temp_dir = tempfile.gettempdir()
    if ext == "":
        # if the file has a GRID-like name but exists within a GDB, its a-ok
        if raster_path.lower().find(".gdb") == -1:
            is_grid = True
        # intermediate processing steps get generated by ModelBuilder
        # within the temp dir, skip these as they are only placeholder
        # names and work despite being invalid GRID names.
        if raster_path.lower().find(temp_dir) >= 0:
            is_grid = False
    return is_grid


def valid_grid_name(raster_path):
    """
    Validate ESRI GRID filenames. The file doesn't exist, so use
    naming to validate a potential name.
    Arguments:

        raster_path -- raster path name to validate

    Returns:
        valid raster boolean
    """

    valid = True
    # GRIDs are the default for any file without a trailing extension.
    if raster_is_grid(raster_path):
        if len(raster_path) > 128:
            valid = False
        else:
            grid_name = os.path.basename(raster_path)
            # Encode all the rules into a regular expression:
            #  - no longer than 13 characters
            #  - must start with a letter
            #  - only letters, numbers, and underscores.
            grid_regex = '^[A-Za-z]{1}[A-Za-z0-9_]{0,12}$'
            if re.match(grid_regex, grid_name) is None:
                valid = False

    return valid


def dedent(text, ending='\r\n'):
    text = text.replace('\n', ending)
    return textwrap.dedent(text)


def makeDefaultFilename(name):
    if utils.get_workspace() is None:
        return None
    else:
        workspace = utils.get_workspace()
        return os.path.join(workspace, name)


class Toolbox(object):
    """ Benthic Terrain Modeler Python toolbox metaclass."""
    def __init__(self):
        self.label = u'Benthic Terrain Modeler'
        self.alias = 'btm'
        self.tools = [
            # Utilities
            setworkspace,       # set workspace for all tools
            # Bathymetric Position Index
            broadscalebpi,      # broad scale
            finescalebpi,       # file scale
            standardizebpi,     # convert BPI values to standardized scores
            # Geomorphology Operations
            btmslope,           # compute slope
            statisticalaspect,  # break aspect up trigonometrically
            surfacetoplanar,    # compare surface area to planar area
            terrainruggedness,  # VRM, a measure of roughness
            arcchordratio,         # ACR rugosity index
            # Summary Statistics
            depthstatistics,    # depth summary statistics
            scalecomparison,    # compare scales of analysis
            multiplescales,      # run tools at multiple scales
            # Create Classification of Zones/Types
            classifyterrain,    # run classification
            runfullmodel        # run all model steps
        ]


# tools below this section, one class per tool.
class setworkspace(object):
    def __init__(self):
        self.label = u'Set Default BTM Workspace'
        self.canRunInBackground = False
        self.description = dedent("""\
                Save a default workspace location to disk""")

    def getParameterInfo(self):
        # Output_Workspace
        out_workspace = arcpy.Parameter()
        out_workspace.name = u'Output_Workspace'
        out_workspace.displayName = u'Output Workspace'
        out_workspace.parameterType = 'Required'
        out_workspace.direction = 'Input'
        out_workspace.datatype = dt.format('Workspace')

        return [out_workspace]

    def execute(self, parameters, messages):
        workspace = parameters[0].valueAsText
        btm_dir = os.path.dirname(os.path.dirname(os.path.dirname(__file__)))
        workspace_file = os.path.join(btm_dir, 'workspace.json')
        with open(workspace_file, 'w') as outfile:
            json.dump(workspace, outfile)


class broadscalebpi(object):
    """ Calculate Broad-scale Bathymetric Position Index (BPI).  """

    def __init__(self):
        self.label = u'Build Broad Scale BPI'
        self.description = dedent("""\
            The concept of bathymetric position is central to the benthic
            terrain classification process that is utilized by BTM.
            Bathymetric Position Index (BPI) is a measure of where a
            referenced location is relative to the locations surrounding it.
            BPI is derived from an input bathymetric data set and itself is
            a modification of the topographic position index (TPI) algorithm
            that is used in the terrestrial environment. The application of
            TPI to develop terrain classifications was explored and
            developed by Andrew Weiss during his study of terrestrial
            watersheds in Central Oregon (Weiss 2001). These applications
            can be carried into the benthic environment through BPI.

            A broad-scale BPI data set allows you to identify larger
            features within the benthic landscape.""")
        self.category = 'Bathymetric Position Index (BPI)'
        self.canRunInBackground = False
        # parameter names
        self.cols = ['bathy', 'inner', 'outer', 'scale_factor', 'output']

    def getParameterInfo(self):
        # Input_bathymetric_raster
        input_raster = arcpy.Parameter()
        input_raster.name = u'Input_bathymetric_raster'
        input_raster.displayName = u'Input bathymetric raster'
        input_raster.parameterType = 'Required'
        input_raster.direction = 'Input'
        input_raster.datatype = dt.format('Raster Layer')

        # Inner_radius
        inner_radius = arcpy.Parameter()
        inner_radius.name = u'Inner_radius'
        inner_radius.displayName = u'Inner radius'
        inner_radius.parameterType = 'Required'
        inner_radius.direction = 'Input'
        inner_radius.datatype = dt.format('Long')

        # Outer_radius
        outer_radius = arcpy.Parameter()
        outer_radius.name = u'Outer_radius'
        outer_radius.displayName = u'Outer radius'
        outer_radius.parameterType = 'Required'
        outer_radius.direction = 'Input'
        outer_radius.datatype = dt.format('Long')

        # Scale Factor
        scale_factor = arcpy.Parameter()
        scale_factor.name = 'Scale_factor'
        scale_factor.displayName = 'Scale factor'
        scale_factor.parameterType = 'Optional'
        scale_factor.datatype = dt.format('Long')
        scale_factor.enabled = False

        # Output_raster
        output_raster = arcpy.Parameter()
        output_raster.name = u'Output_raster'
        output_raster.displayName = u'Output raster'
        output_raster.parameterType = 'Required'
        output_raster.direction = 'Output'
        output_raster.datatype = dt.format('File')

        return [input_raster, inner_radius, outer_radius,
                scale_factor, output_raster]

    def isLicensed(self):
        return True

    def updateParameters(self, parameters):

        bathy = parameters[self.cols.index('bathy')].valueAsText
        outer_radius = parameters[self.cols.index('outer')].valueAsText
        scale_factor = parameters[self.cols.index('scale_factor')]
        output = parameters[self.cols.index('output')]

        if output.value is None and bathy is not None:
            base_name = os.path.splitext(os.path.basename(bathy))[0]
            out_name = '{}_broadbpi.tif'.format(base_name)
            out_path = makeDefaultFilename(out_name)
            output.value = out_path

        if outer_radius is not None and bathy is not None:
            # get the cellsize of the input raster; assume same in X & Y
            cellsize = utils.raster_properties(bathy, "CELLSIZEY")
            # calculate our 'scale factor', modify the param
            scale_factor.value = math.ceil(cellsize * int(outer_radius) - 0.5)

        return

    def updateMessages(self, parameters):
        inner_radius = parameters[1].valueAsText
        outer_radius = parameters[2].valueAsText
        output = parameters[4].valueAsText

        if outer_radius is not None and inner_radius is not None:
            inner_rad = int(inner_radius)
            outer_rad = int(outer_radius)
            # test that the outer radius exceeds the inner radius.
            if inner_rad >= outer_rad:
                parameters[2].setErrorMessage(MSG_INVALID_RADIUS)

        # validate the output GRID name
        if output is not None:
            if not valid_grid_name(output):
                parameters[4].setErrorMessage(MSG_INVALID_GRID)

        return

    def execute(self, parameters, messages):
        # run related python script with selected input parameters
        from scripts import bpi
        bpi.main(
            bathy=parameters[0].valueAsText,
            inner_radius=parameters[1].valueAsText,
            outer_radius=parameters[2].valueAsText,
            out_raster=parameters[4].valueAsText,
            bpi_type='broad')


class finescalebpi(object):
    """ Calculate Fine-scale Bathymetric Position Index (BPI).  """

    def __init__(self):
        self.label = u'Build Fine Scale BPI'
        self.description = dedent("""\
            The concept of bathymetric position is central to the benthic
            terrain classification process that is utilized by the BTM.
            Bathymetric Position Index (BPI) is a measure of where a
            referenced location is relative to the locations surrounding it.
            BPI is derived from an input bathymetric data set and itself is
            a modification of the topographic position index (TPI) algorithm
            that is used in the terrestrial environment. The application of
            TPI to develop terrain classifications was explored and
            developed by Andrew Weiss during his study of terrestrial
            watersheds in Central Oregon (Weiss 2001). These applications
            can be carried into the benthic environment through BPI.

            A broad-scale BPI data set allows you to identify larger
            features within the benthic landscape.""")
        self.canRunInBackground = False
        self.category = 'Bathymetric Position Index (BPI)'
        # parameter names
        self.cols = ['bathy', 'inner', 'outer', 'scale_factor', 'output']

    def getParameterInfo(self):
        # Input_bathymetric_raster
        input_raster = arcpy.Parameter()
        input_raster.name = u'Input_bathymetric_raster'
        input_raster.displayName = u'Input bathymetric raster'
        input_raster.parameterType = 'Required'
        input_raster.direction = 'Input'
        input_raster.datatype = dt.format('Raster Layer')

        # Inner_radius
        inner_radius = arcpy.Parameter()
        inner_radius.name = u'Inner_radius'
        inner_radius.displayName = u'Inner radius'
        inner_radius.parameterType = 'Required'
        inner_radius.direction = 'Input'
        inner_radius.datatype = dt.format('Long')

        # Outer_radius
        outer_radius = arcpy.Parameter()
        outer_radius.name = u'Outer_radius'
        outer_radius.displayName = u'Outer radius'
        outer_radius.parameterType = 'Required'
        outer_radius.direction = 'Input'
        outer_radius.datatype = dt.format('Long')

        # Scale Factor
        scale_factor = arcpy.Parameter()
        scale_factor.name = 'Scale_factor'
        scale_factor.displayName = 'Scale factor'
        scale_factor.parameterType = 'Optional'
        scale_factor.datatype = dt.format('Long')
        scale_factor.enabled = False

        # Output_raster
        output_raster = arcpy.Parameter()
        output_raster.name = u'Output_raster'
        output_raster.displayName = u'Output raster'
        output_raster.parameterType = 'Required'
        output_raster.direction = 'Output'
        output_raster.datatype = dt.format('File')

        # TODO: implement mutlvalue support
        multivalue = arcpy.Parameter()
        multivalue.name = u'Test multi'
        multivalue.displayName = u'Test multi'
        multivalue.parameterType = 'Optional'
        multivalue.direction = 'Input'
        multivalue.datatype = dt.format('Any Value')

        return [input_raster, inner_radius, outer_radius,
                scale_factor, output_raster]

    def isLicensed(self):
        return True

    def updateParameters(self, parameters):

        bathy = parameters[self.cols.index('bathy')].valueAsText
        outer_radius = parameters[self.cols.index('outer')].valueAsText
        scale_factor = parameters[self.cols.index('scale_factor')]
        output = parameters[self.cols.index('output')]

        if output.value is None and bathy is not None:
            base_name = os.path.splitext(os.path.basename(bathy))[0]
            out_name = '{}_finebpi.tif'.format(base_name)
            out_path = makeDefaultFilename(out_name)
            output.value = out_path

        if outer_radius is not None and bathy is not None:
            # get the cellsize of the input raster; assume same in X & Y
            cellsize = utils.raster_properties(bathy, "CELLSIZEY")
            # calculate our 'scale factor', modify the param
            scale_factor.value = math.ceil(cellsize * int(outer_radius) - 0.5)

        return

    def updateMessages(self, parameters):
        inner_radius = parameters[1].valueAsText
        outer_radius = parameters[2].valueAsText
        output = parameters[4].valueAsText
        if outer_radius is not None and inner_radius is not None:
            inner_rad = int(inner_radius)
            outer_rad = int(outer_radius)
            # test that the outer radius exceeds the inner radius.
            if inner_rad >= outer_rad:
                parameters[2].setErrorMessage(MSG_INVALID_RADIUS)

        # validate the output GRID name
        if output is not None:
            if not valid_grid_name(output):
                parameters[4].setErrorMessage(MSG_INVALID_GRID)

        return

    def execute(self, parameters, messages):
        # run related python script with selected input parameters
        from scripts import bpi
        bpi.main(
            bathy=parameters[0].valueAsText,
            inner_radius=parameters[1].valueAsText,
            outer_radius=parameters[2].valueAsText,
            out_raster=parameters[4].valueAsText,
            bpi_type='fine')


class standardizebpi(object):
    """
    Standardize BPI rasters.
    """

    def __init__(self):
        self.label = u'Standardize BPIs'
        self.canRunInBackground = False
        self.category = 'Bathymetric Position Index (BPI)'
        self.cols = [
            'broad_input', 'broad_mean', 'broad_stddev', 'broad_output',
            'fine_input', 'fine_mean', 'fine_stddev', 'fine_output'
        ]

    def getParameterInfo(self):
        # Input_BPI_raster
        broad_raster = arcpy.Parameter()
        broad_raster.name = u'Broad_BPI_raster'
        broad_raster.displayName = u'Broad BPI raster'
        broad_raster.parameterType = 'Required'
        broad_raster.direction = 'Input'
        broad_raster.datatype = dt.format('Raster Layer')

        # dervied statistics
        broad_mean = arcpy.Parameter()
        broad_mean.name = 'Broad_BPI_Mean'
        broad_mean.displayName = 'Broad BPI Mean'
        broad_mean.parameterType = 'Required'
        broad_mean.datatype = dt.format('Double')
        broad_mean.enabled = False
        broad_mean.value = 0

        broad_stddev = arcpy.Parameter()
        broad_stddev.name = 'Broad_BPI_Standard_deviation'
        broad_stddev.displayName = 'Broad BPI Standard Deviation'
        broad_stddev.parameterType = 'Required'
        broad_stddev.datatype = dt.format('Double')
        broad_stddev.enabled = False
        broad_stddev.value = 0

        # Output_raster
        broad_std_output = arcpy.Parameter()
        broad_std_output.name = u'Output_broad_raster'
        broad_std_output.displayName = u'Output Standardized Broad BPI raster'
        broad_std_output.parameterType = 'Required'
        broad_std_output.direction = 'Output'
        broad_std_output.datatype = dt.format('File')

        # Input_BPI_raster
        fine_raster = arcpy.Parameter()
        fine_raster.name = u'Fine_BPI_raster'
        fine_raster.displayName = u'Fine BPI raster'
        fine_raster.parameterType = 'Required'
        fine_raster.direction = 'Input'
        fine_raster.datatype = dt.format('Raster Layer')

        # dervied statistics
        fine_mean = arcpy.Parameter()
        fine_mean.name = 'Fine_BPI_Mean'
        fine_mean.displayName = 'Fine BPI Mean'
        fine_mean.parameterType = 'Required'
        fine_mean.datatype = dt.format('Double')
        fine_mean.enabled = False
        fine_mean.value = 0

        fine_stddev = arcpy.Parameter()
        fine_stddev.name = 'Fine_BPI_Standard_deviation'
        fine_stddev.displayName = 'Fine BPI Standard Deviation'
        fine_stddev.parameterType = 'Required'
        fine_stddev.datatype = dt.format('Double')
        fine_stddev.enabled = False
        fine_stddev.value = 0

        # Output_raster
        fine_std_output = arcpy.Parameter()
        fine_std_output.name = u'Output_fine_raster'
        fine_std_output.displayName = u'Output Standardized Fine BPI raster'
        fine_std_output.parameterType = 'Required'
        fine_std_output.direction = 'Output'
        fine_std_output.datatype = dt.format('File')

        return [broad_raster, broad_mean, broad_stddev, broad_std_output,
                fine_raster, fine_mean, fine_stddev, fine_std_output]

    def isLicensed(self):
        return True

    def updateParameters(self, parameters):
        fine_input = parameters[self.cols.index('fine_input')].valueAsText
        broad_input = parameters[self.cols.index('broad_input')].valueAsText
        fine_output = parameters[self.cols.index('fine_output')]
        broad_output = parameters[self.cols.index('broad_output')]

        if broad_output.value is None and broad_input is not None:
            broad_base_name = os.path.splitext(
                os.path.basename(broad_input))[0]
            broad_out_name = '{}_std.tif'.format(broad_base_name)
            broad_out_path = makeDefaultFilename(broad_out_name)
            broad_output.value = broad_out_path
        if fine_output.value is None and fine_input is not None:
            fine_base_name = os.path.splitext(os.path.basename(fine_input))[0]
            fine_out_name = '{}_std.tif'.format(fine_base_name)
            fine_out_path = makeDefaultFilename(fine_out_name)
            fine_output.value = fine_out_path
        return

    def updateMessages(self, parameters):

        for label in ['broad', 'fine']:
            input_raster = parameters[self.cols.index(label +
                                                      '_input')].valueAsText
            if input_raster is not None:
                (mean, stddev) = self.getRasterStats(input_raster)
                if mean is not None:
                    # try modifying our variables
                    parameters[self.cols.index(label +
                                               '_mean')].value = mean
                    parameters[self.cols.index(label +
                                               '_stddev')].value = stddev

            # Validate GRID outputs.
            out_param = self.cols.index(label + '_output')
            output_raster = parameters[out_param].valueAsText
            if output_raster is not None:
                if not valid_grid_name(output_raster):
                    parameters[out_param].setErrorMessage(MSG_INVALID_GRID)
        return

    def getRasterStats(self, input_raster=None):
        result = (None, None)
        if input_raster is not None:
            try:
                result = (utils.raster_properties(input_raster, 'MEAN'),
                          utils.raster_properties(input_raster, 'STD'))
            except:
                # check for raster existence,
                # when running as a model the 'result'
                # may be set, but not actually exist,
                # causing these steps to fail.
                pass
                # f.write("\n\nFULLEXEC: {}\n".format(sys.exc_info()))
        return result

    def execute(self, parameters, messages):
        # run related python script with selected input parameters
        from scripts import standardize_bpi_grids
        # run for broad raster...
        standardize_bpi_grids.main(
            bpi_raster=parameters[0].valueAsText,
            out_raster=parameters[3].valueAsText)
        #  ...and again for fine raster.
        standardize_bpi_grids.main(
            bpi_raster=parameters[4].valueAsText,
            out_raster=parameters[7].valueAsText)


class statisticalaspect(object):
    """ Calculate statistical aspect, uses standard SA function internally."""
    def __init__(self):
        self.label = u'Calculate Statistical Aspect'
        self.canRunInBackground = False
        self.category = 'Surface Derivatives and Statistics'

    def getParameterInfo(self):
        # Input_bathymetric_raster
        input_raster = arcpy.Parameter()
        input_raster.name = u'Input_bathymetric_raster'
        input_raster.displayName = u'Input bathymetric raster'
        input_raster.parameterType = 'Required'
        input_raster.direction = 'Input'
        input_raster.datatype = dt.format('Raster Layer')

        # Output Sin raster
        output_sin_raster = arcpy.Parameter()
        output_sin_raster.name = u'Output_sin_raster'
        output_sin_raster.displayName = u'Output Sin(Aspect) raster'
        output_sin_raster.parameterType = 'Required'
        output_sin_raster.direction = 'Output'
        output_sin_raster.datatype = dt.format('File')

        # Output Cos raster
        output_cos_raster = arcpy.Parameter()
        output_cos_raster.name = u'Output_cos_raster'
        output_cos_raster.displayName = u'Output Cos(Aspect) raster'
        output_cos_raster.parameterType = 'Required'
        output_cos_raster.direction = 'Output'
        output_cos_raster.datatype = dt.format('File')

        return [input_raster, output_sin_raster, output_cos_raster]

    def isLicensed(self):
        return True

    def updateParameters(self, parameters):
        in_raster = parameters[0].valueAsText
        output_sin = parameters[1]
        output_cos = parameters[2]

        if output_sin.value is None and in_raster is not None:
            sin_base_name = os.path.splitext(os.path.basename(in_raster))[0]
            sin_out_name = '{}_sin_aspect.tif'.format(sin_base_name)
            sin_out_path = makeDefaultFilename(sin_out_name)
            output_sin.value = sin_out_path
        if output_cos.value is None and in_raster is not None:
            cos_base_name = os.path.splitext(os.path.basename(in_raster))[0]
            cos_out_name = '{}_cos_aspect.tif'.format(cos_base_name)
            cos_out_path = makeDefaultFilename(cos_out_name)
            output_cos.value = cos_out_path
        return

    def updateMessages(self, parameters):
        output_sin = parameters[1].valueAsText
        output_cos = parameters[2].valueAsText

        # validate the output GRID name
        if output_sin is not None:
            if not valid_grid_name(output_sin):
                parameters[1].setErrorMessage(MSG_INVALID_GRID)

        if output_cos is not None:
            if not valid_grid_name(output_cos):
                parameters[2].setErrorMessage(MSG_INVALID_GRID)
        return

    def execute(self, parameters, messages):
        # run related python script with selected input parameters
        from scripts import aspect
        aspect.main(
            bathy=parameters[0].valueAsText,
            out_sin_raster=parameters[1].valueAsText,
            out_cos_raster=parameters[2].valueAsText)


class btmslope(object):
    """ Calculate slope, uses standard SA function internally."""
    def __init__(self):
        self.label = u'Calculate Slope'
        self.canRunInBackground = False
        self.category = 'Surface Derivatives and Statistics'

    def getParameterInfo(self):
        # Input_bathymetric_raster
        input_raster = arcpy.Parameter()
        input_raster.name = u'Input_bathymetric_raster'
        input_raster.displayName = u'Input bathymetric raster'
        input_raster.parameterType = 'Required'
        input_raster.direction = 'Input'
        input_raster.datatype = dt.format('Raster Layer')

        # Output_raster
        output_raster = arcpy.Parameter()
        output_raster.name = u'Output_raster'
        output_raster.displayName = u'Output raster'
        output_raster.parameterType = 'Required'
        output_raster.direction = 'Output'
        output_raster.datatype = dt.format('File')

        return [input_raster, output_raster]

    def isLicensed(self):
        return True

    def updateParameters(self, parameters):
        in_raster = parameters[0].valueAsText
        out_slope = parameters[1]

        if out_slope.value is None and in_raster is not None:
            slope_base_name = os.path.splitext(os.path.basename(in_raster))[0]
            slope_out_name = '{}_slope.tif'.format(slope_base_name)
            slope_out_path = makeDefaultFilename(slope_out_name)
            out_slope.value = slope_out_path
        return

    def updateMessages(self, parameters):
        output = parameters[1].valueAsText
        # validate the output GRID name
        if output is not None:
            if not valid_grid_name(output):
                parameters[1].setErrorMessage(MSG_INVALID_GRID)

        return

    def execute(self, parameters, messages):
        # run related python script with selected input parameters
        from scripts import slope
        slope.main(
            bathy=parameters[0].valueAsText,
            out_raster=parameters[1].valueAsText)


class classifyterrain(object):
    """ Classify Benthic Terrain based on classification dictionary. """
    def __init__(self):
        self.label = u'Classify Benthic Terrain'
        self.canRunInBackground = False
        self.category = 'Terrain Classification'

    def getParameterInfo(self):
        # Classification Dictionary
        class_dict = arcpy.Parameter()
        class_dict.name = u'Classification_dictionary'
        class_dict.displayName = u'Classification dictionary'
        class_dict.direction = 'Input'
        class_dict.datatype = dt.format('File')
        class_dict.parameterType = 'Required'

        # classification dictionary must be of the types we parse.
        class_dict.filter.list = ['csv', 'xls', 'xlsx', 'xml']

        # Standardized broad-scale BPI raster
        broad_bpi_std = arcpy.Parameter()
        broad_bpi_std.name = u'Standardized_broad-scale_BPI_raster'
        broad_bpi_std.displayName = u'Standardized broad-scale BPI raster'
        broad_bpi_std.parameterType = 'Required'
        broad_bpi_std.direction = 'Input'
        broad_bpi_std.datatype = dt.format('Raster Layer')

        # Standardized fine-scale BPI raster
        fine_bpi_std = arcpy.Parameter()
        fine_bpi_std.name = u'Standardized_fine-scale_BPI_raster'
        fine_bpi_std.displayName = u'Standardized fine-scale BPI raster'
        fine_bpi_std.parameterType = 'Required'
        fine_bpi_std.direction = 'Input'
        fine_bpi_std.datatype = dt.format('Raster Layer')

        # Slope_raster
        slope = arcpy.Parameter()
        slope.name = u'Slope_raster'
        slope.displayName = u'Slope raster'
        slope.parameterType = 'Required'
        slope.direction = 'Input'
        slope.datatype = dt.format('Raster Layer')

        # Bathymetry raster
        bathy = arcpy.Parameter()
        bathy.name = u'Bathymetry_raster'
        bathy.displayName = u'Bathymetry raster'
        bathy.parameterType = 'Required'
        bathy.direction = 'Input'
        bathy.datatype = dt.format('Raster Layer')

        # Output_raster
        zones_raster = arcpy.Parameter()
        zones_raster.name = u'Output_zones_raster'
        zones_raster.displayName = u'Output Zones Raster'
        zones_raster.parameterType = 'Required'
        zones_raster.direction = 'Output'
        zones_raster.datatype = dt.format('File')
        return [class_dict, broad_bpi_std, fine_bpi_std,
                slope, bathy, zones_raster]

    def isLicensed(self):
        return True

    def updateParameters(self, parameters):
        bathy = parameters[4].valueAsText
        zones = parameters[5]

        if zones.value is None and bathy is not None:
            zones_base_name = os.path.splitext(os.path.basename(bathy))[0]
            zones_out_name = '{}_classified.tif'.format(zones_base_name)
            zones_out_path = makeDefaultFilename(zones_out_name)
            zones.value = zones_out_path
        return

    def updateMessages(self, parameters):
        output = parameters[5].valueAsText
        # validate the output GRID name
        if output is not None:
            if not valid_grid_name(output):
                parameters[5].setErrorMessage(MSG_INVALID_GRID)
        return

    def execute(self, parameters, messages):
        from scripts import classify
        classify.main(
            classification_file=parameters[0].valueAsText,
            bpi_broad_std=parameters[1].valueAsText,
            bpi_fine_std=parameters[2].valueAsText,
            slope=parameters[3].valueAsText,
            bathy=parameters[4].valueAsText,
            out_raster=parameters[5].valueAsText)


class runfullmodel(object):
    """ Run all model steps to classify benthic terrain. """

    def __init__(self):
        self.label = u'Run All Model Steps'
        self.canRunInBackground = False
        self.category = 'Terrain Classification'
        self.cols = [
            'out_workspace', 'bathy', 'broad_bpi_inner', 'broad_bpi_outer',
            'fine_bpi_inner', 'fine_bpi_outer', 'class_dict', 'zones_raster'
        ]

    def getParameterInfo(self):
        # Output_Workspace
        out_workspace = arcpy.Parameter()
        out_workspace.name = u'Output_Workspace'
        out_workspace.displayName = u'Output Workspace'
        out_workspace.parameterType = 'Required'
        out_workspace.direction = 'Input'
        out_workspace.datatype = dt.format('Workspace')

        # Bathymetry raster
        bathy = arcpy.Parameter()
        bathy.name = u'Bathymetry_raster'
        bathy.displayName = u'Bathymetry raster'
        bathy.parameterType = 'Required'
        bathy.direction = 'Input'
        bathy.datatype = dt.format('Raster Layer')

        # Broad-scale BPI raster inner radius
        broad_bpi_inner = arcpy.Parameter()
        broad_bpi_inner.name = u'broad-scale_BPI_inner_radius'
        broad_bpi_inner.displayName = u'broad-scale BPI inner radius'
        broad_bpi_inner.parameterType = 'Required'
        broad_bpi_inner.direction = 'Input'
        broad_bpi_inner.datatype = dt.format('Long')

        # Broad-scale BPI raster inner radius
        broad_bpi_outer = arcpy.Parameter()
        broad_bpi_outer.name = u'broad-scale_BPI_outer_radius'
        broad_bpi_outer.displayName = u'broad-scale BPI outer radius'
        broad_bpi_outer.parameterType = 'Required'
        broad_bpi_outer.direction = 'Input'
        broad_bpi_outer.datatype = dt.format('Long')

        # Fine-scale BPI raster inner radius
        fine_bpi_inner = arcpy.Parameter()
        fine_bpi_inner.name = u'fine-scale_BPI_inner_radius'
        fine_bpi_inner.displayName = u'fine-scale BPI inner radius'
        fine_bpi_inner.parameterType = 'Required'
        fine_bpi_inner.direction = 'Input'
        fine_bpi_inner.datatype = dt.format('Long')

        # Fine-scale BPI raster inner radius
        fine_bpi_outer = arcpy.Parameter()
        fine_bpi_outer.name = u'fine-scale_BPI_outer_radius'
        fine_bpi_outer.displayName = u'fine-scale BPI outer radius'
        fine_bpi_outer.parameterType = 'Required'
        fine_bpi_outer.direction = 'Input'
        fine_bpi_outer.datatype = dt.format('Long')

        # Classification Dictionary
        class_dict = arcpy.Parameter()
        class_dict.name = u'Classification_dictionary'
        class_dict.displayName = u'Classification dictionary'
        class_dict.direction = 'Input'
        class_dict.datatype = dt.format('File')
        class_dict.parameterType = 'Required'

        # classification dictionary must be of the types we parse.
        class_dict.filter.list = ['csv', 'xls', 'xlsx', 'xml']

        # Output_raster
        zones_raster = arcpy.Parameter()
        zones_raster.name = u'Output_zones_raster'
        zones_raster.displayName = u'Output Zones Raster'
        zones_raster.parameterType = 'Required'
        zones_raster.direction = 'Output'
        zones_raster.datatype = dt.format('File')

        return [out_workspace, bathy, broad_bpi_inner, broad_bpi_outer,
                fine_bpi_inner, fine_bpi_outer, class_dict, zones_raster]

    def isLicensed(self):
        return True

    def validateRadius(self, inner_param, outer_param):
        is_valid = True
        inner_val = inner_param.valueAsText
        outer_val = outer_param.valueAsText

        if inner_val is not None and outer_val is not None:
            inner_rad = int(inner_val)
            outer_rad = int(outer_val)
            # test that the outer radius exceeds the inner radius.
            if inner_rad >= outer_rad:
                is_valid = False
        return is_valid

    def updateParameters(self, parameters):
        bathy = parameters[self.cols.index('bathy')].valueAsText
        zones = parameters[self.cols.index('zones_raster')]
        workspace = parameters[self.cols.index('out_workspace')]

        if workspace.value is None:
            workspace.value = utils.get_workspace()

        if zones.value is None and bathy is not None:
            zones_base_name = os.path.splitext(os.path.basename(bathy))[0]
            zones_out_name = '{}_classified.tif'.format(zones_base_name)
            zones_out_path = makeDefaultFilename(zones_out_name)
            zones.value = zones_out_path
        return

    def updateMessages(self, parameters):
        broad_inner = parameters[self.cols.index('broad_bpi_inner')]
        broad_outer = parameters[self.cols.index('broad_bpi_outer')]
        if not self.validateRadius(broad_inner, broad_outer):
            broad_inner.setErrorMessage(MSG_INVALID_RADIUS)

        fine_inner = parameters[self.cols.index('fine_bpi_inner')]
        fine_outer = parameters[self.cols.index('fine_bpi_outer')]
        if not self.validateRadius(fine_inner, fine_outer):
            fine_inner.setErrorMessage(MSG_INVALID_RADIUS)

        return

    def execute(self, parameters, messages):
        from scripts import btm_model
        btm_model.main(
            out_workspace=parameters[0].valueAsText,
            input_bathymetry=parameters[1].valueAsText,
            broad_bpi_inner_radius=parameters[2].valueAsText,
            broad_bpi_outer_radius=parameters[3].valueAsText,
            fine_bpi_inner_radius=parameters[4].valueAsText,
            fine_bpi_outer_radius=parameters[5].valueAsText,
            classification_dict=parameters[6].valueAsText,
            output_zones=parameters[7].valueAsText)


class surfacetoplanar(object):
    """Compute Surface Area to Planar Area (ratio)."""

    def __init__(self):
        self.label = u'Surface Area to Planar Area'
        self.description = dedent(
            """Measure terrain ruggedness by calculating the ratio
            between the surface area and the planar area, as described
            in Jenness 2002.""")
        self.canRunInBackground = False
        self.category = 'Rugosity'

    def getParameterInfo(self):
        # Bathymetry_Raster
        input_raster = arcpy.Parameter()
        input_raster.name = u'Bathymetry_Raster'
        input_raster.displayName = u'Bathymetry Raster'
        input_raster.parameterType = 'Required'
        input_raster.direction = 'Input'
        input_raster.datatype = dt.format('Raster Layer')

        # Output_Raster
        output_raster = arcpy.Parameter()
        output_raster.name = u'Output_Raster'
        output_raster.displayName = u'Output Raster'
        output_raster.parameterType = 'Required'
        output_raster.direction = 'Output'
        output_raster.datatype = dt.format('File')

        # ACR Correction
        acr_correction = arcpy.Parameter()
        acr_correction.name = u'ACR_Correction'
        acr_correction.displayName = u'Correct Planar Area for Slope ' + \
                                     u'(Arc-Chord Ratio Rugosity)'
        acr_correction.parameterType = 'Optional'
        acr_correction.direction = 'Input'
        acr_correction.datatype = dt.format('Boolean')
        acr_correction.value = 'True'

        # Area_Raster
        area_raster = arcpy.Parameter()
        area_raster.name = u'Area_Raster'
        area_raster.displayName = u'Area Raster'
        area_raster.parameterType = 'Optional'
        area_raster.direction = 'Output'
        area_raster.datatype = dt.format('Raster Dataset')

        return [input_raster, output_raster, acr_correction, area_raster]

    def isLicensed(self):
        return True

    def updateParameters(self, parameters):
        bathy = parameters[0].valueAsText
        sapa = parameters[1]

        if sapa.value is None and bathy is not None:
            sapa_base_name = os.path.splitext(os.path.basename(bathy))[0]
            sapa_out_name = '{}_SAtoPA.tif'.format(sapa_base_name)
            sapa_out_path = makeDefaultFilename(sapa_out_name)
            sapa.value = sapa_out_path
        return

    def updateMessages(self, parameters):
        output = parameters[1].valueAsText
        # validate the output GRID name
        if output is not None:
            if not valid_grid_name(output):
                parameters[1].setErrorMessage(MSG_INVALID_GRID)
        return

    def execute(self, parameters, messages):
        # run related python script with selected input parameters
        from scripts import surface_area_to_planar_area
        surface_area_to_planar_area.main(
            in_raster=parameters[0].valueAsText,
            out_raster=parameters[1].valueAsText,
            acr_correction=parameters[2].valueAsText,
            area_raster=parameters[3].valueAsText)


class terrainruggedness(object):
    """Compute Terrain Ruggedness Measure (VRM)."""

    def __init__(self):
        self.label = u'Terrain Ruggedness (VRM)'
        self.description = dedent("""\
                Measure terrain ruggedness by calculating the vector ruggedness
                measure (VRM), as described in Sappington et al, 2007.""")
        self.canRunInBackground = False
        self.category = 'Rugosity'

    def getParameterInfo(self):
        # Bathymetry_Raster
        input_raster = arcpy.Parameter()
        input_raster.name = u'Bathymetry_Raster'
        input_raster.displayName = u'Bathymetry Raster'
        input_raster.parameterType = 'Required'
        input_raster.direction = 'Input'
        input_raster.datatype = dt.format('Raster Layer')

        # Neighborhood_Size
        neighborhood = arcpy.Parameter()
        neighborhood.name = u'Neighborhood_Size'
        neighborhood.displayName = u'Neighborhood Size'
        neighborhood.parameterType = 'Required'
        neighborhood.direction = 'Input'
        neighborhood.datatype = dt.format('Long')

        # Output_Raster
        output_raster = arcpy.Parameter()
        output_raster.name = u'Output_Raster'
        output_raster.displayName = u'Output Raster'
        output_raster.parameterType = 'Required'
        output_raster.direction = 'Output'
        output_raster.datatype = dt.format('File')

        return [input_raster, neighborhood, output_raster]

    def isLicensed(self):
        return True

    def updateParameters(self, parameters):
        bathy = parameters[0].valueAsText
        nbh = parameters[1].valueAsText
        vrm = parameters[2]

        if vrm.value is None and bathy is not None and nbh is not None:
            vrm_base_name = os.path.splitext(os.path.basename(bathy))[0]
            n_label = "{:03d}".format(int(nbh))
            vrm_out_name = '{}_ruggedness{}.tif'.format(vrm_base_name, n_label)
            vrm_out_path = makeDefaultFilename(vrm_out_name)
            vrm.value = vrm_out_path
        return

    def updateMessages(self, parameters):
        output = parameters[2].valueAsText
        # validate the output GRID name
        if output is not None:
            if not valid_grid_name(output):
                parameters[2].setErrorMessage(MSG_INVALID_GRID)

        n_size = parameters[1].valueAsText
        if n_size is not None:
            if float(n_size) % 2 == 0:
                parameters[1].setWarningMessage(
                    "If an even neighborhood size is used, neighborhood"
                    " coordinates will be computed using truncation."
                    " Use an odd neighborhood size"
                    " to avoid unexpected results.")

        return

    def execute(self, parameters, messages):
        # run related python script with selected input parameters
        from scripts import ruggedness
        ruggedness.main(
            in_raster=parameters[0].valueAsText,
            neighborhood_size=parameters[1].valueAsText,
            out_raster=parameters[2].valueAsText)


class arcchordratio(object):

    def __init__(self):
        self.label = u'Arc-Chord Ratio'
        self.description = dedent("""\
               Arc-cord ratio (Model 2) as described by Du Preez (2014)""")
        self.canRunInBackground = False
        self.category = 'Rugosity'

    def getParameterInfo(self):
        # Bathymetry_Raster
        input_raster = arcpy.Parameter()
        input_raster.name = u'Bathymetry_Raster'
        input_raster.displayName = u'Bathymetry Raster'
        input_raster.parameterType = 'Required'
        input_raster.direction = 'Input'
        input_raster.datatype = dt.format('Raster Layer')

        # Area of Interest
        areaOfInterest = arcpy.Parameter()
        areaOfInterest.name = u'Area of Interest'
        areaOfInterest.displayName = u'Area of Interest'
        areaOfInterest.parameterType = 'Required'
        areaOfInterest.direction = 'Input'
        areaOfInterest.datatype = dt.format('Feature Class')

        # Save TINs
        saveTINs = arcpy.Parameter()
        saveTINs.name = u'Save TINs'
        saveTINs.displayName = u'Save Output Contoured and Planar TINs'
        saveTINs.parameterType = 'Optional'
        saveTINs.direction = 'Input'
        saveTINs.datatype = dt.format('Boolean')
        saveTINs.value = 'False'

        # Output_Workspace
        out_workspace = arcpy.Parameter()
        out_workspace.name = u'Output_Workspace'
        out_workspace.displayName = u'Output Workspace'
        out_workspace.parameterType = 'Optional'
        out_workspace.direction = 'Input'
        out_workspace.datatype = dt.format('Workspace')

        return [input_raster, areaOfInterest, saveTINs, out_workspace]

    def isLicensed(self):
        return True

    def updateParameters(self, parameters):
        workspace = parameters[3]
        current_workspace = utils.get_workspace()
        if current_workspace:
            ws = arcpy.Describe(current_workspace)
            ws_type = set([ws.workspaceType])
            db_types = ['LocalDatabase', 'RemoteDatabase']
            if not ws_type.intersection(db_types):
                if workspace.value is None:
                    workspace.value = current_workspace
        return

    def updateMessages(self, parameters):
        return

    def execute(self, parameters, messages):
        # run related python script with selected input parameters
        from scripts import acr
        acr.main(
            in_raster=parameters[0].valueAsText,
            areaOfInterest=parameters[1].valueAsText,
            saveTINs=parameters[2].valueAsText,
            workspace=parameters[3].valueAsText)


class depthstatistics(object):
    """ Depth Statistics computes a suite of summary statistics. This initial
        version works on a fixed window size, but user feedback has indicated
        a more general version which supported multiple window sizes,
        including vector-based ones, would be preferable.

        Also, this current version uses focal tools, but could be computed in
        one pass using numpy instead, but memory considerations would need
        to be taken into account, or the algorithm would need to operate on
        blocks within the data. see 'rugosity.py' script an example of this
        approach, can use NumPyArrayToRaster and vice versa.
    """

    def __init__(self):
        self.label = u'Calculate Metrics (Depth Statistics)'
        self.canRunInBackground = False
        self.category = 'Surface Derivatives and Statistics'

    def getParameterInfo(self):
        # Bathymetry_Raster
        input_raster = arcpy.Parameter()
        input_raster.name = u'Bathymetry_Raster'
        input_raster.displayName = u'Bathymetry Raster'
        input_raster.parameterType = 'Required'
        input_raster.direction = 'Input'
        input_raster.datatype = dt.format('Raster Layer')

        # Neighborhood_Size
        neighborhood = arcpy.Parameter()
        neighborhood.name = u'Neighborhood_Size'
        neighborhood.displayName = u'Neighborhood Size'
        neighborhood.parameterType = 'Required'
        neighborhood.direction = 'Input'
        neighborhood.datatype = dt.format('Long')

        # Output_Workspace
        out_workspace = arcpy.Parameter()
        out_workspace.name = u'Output_Workspace'
        out_workspace.displayName = u'Output Workspace'
        out_workspace.parameterType = 'Required'
        out_workspace.direction = 'Input'
        out_workspace.datatype = dt.format('Workspace')

        # Statistics to Compute
        statistics = arcpy.Parameter()
        statistics.name = u'Statistics_Computed'
        statistics.displayName = u'Statistics to Compute'
        statistics.parameterType = 'Required'
        statistics.direction = 'Input'
        statistics.datatype = dt.format('String')
        statistics.multiValue = True
        statistics.filter.list = ['Mean Depth', 'Variance',
                                  'Standard Deviation', 'Interquartile Range',
                                  'Kurtosis']

        return [input_raster, neighborhood, out_workspace, statistics]

    def isLicensed(self):
        return True

    def updateParameters(self, parameters):
        workspace = parameters[2]

        if workspace.value is None:
            workspace.value = utils.get_workspace()
        return

    def updateMessages(self, parameters):
        stats = []
        if parameters[3].value:
            stats = parameters[3].valueAsText.split(";")

        if not utils.NETCDF4_EXISTS and ('Kurtosis' in stats or
                                         'Interquartile Range' in stats):
            parameters[3].setWarningMessage(
                "The interquartile range and kurtosis tools require "
                "the NetCDF4 Python library is installed. NetCDF4 "
                "is included in ArcGIS 10.3 and later.")

        if not utils.SCIPY_EXISTS and 'Kurtosis' in stats:
            parameters[3].setWarningMessage(
                "The kurtosis calculation requires the SciPy library "
                "is installed. SciPy is included in ArcGIS 10.4 and "
                "later versions.")
        return

    def execute(self, parameters, messages):
        # run related python script with selected input parameters
        from scripts import depth_statistics
        depth_statistics.main(
            in_raster=parameters[0].valueAsText,
            neighborhood_size=parameters[1].valueAsText,
            out_workspace=parameters[2].valueAsText,
            out_stats_raw=parameters[3].valueAsText)


class scalecomparison(object):
    """ Create a visual aid for easy comparison between statistics
        computed at different scales """
    def __init__(self):
        self.label = u'Compare Scales of Analysis'
        self.canRunInBackground = False
        self.category = 'Multi-Scale Analysis'

    def getParameterInfo(self):

        # Bathymetry raster
        bathy = arcpy.Parameter()
        bathy.name = u'Bathymetry_raster'
        bathy.displayName = u'Bathymetry raster'
        bathy.parameterType = 'Required'
        bathy.direction = 'Input'
        bathy.datatype = dt.format('Raster Layer')

        # Image Filter
        imgfilter = arcpy.Parameter()
        imgfilter.name = u'Filter'
        imgfilter.displayName = u'Filter'
        imgfilter.parameterType = 'Required'
        imgfilter.direction = 'Input'
        imgfilter.datatype = dt.format('String')
        imgfilter.value = 'Median'
        imgfilter.filter.list = ['Median', 'Minimum', 'Maximum', 'Percentile']

        # Percentile
        percentile = arcpy.Parameter()
        percentile.name = u'Percentile'
        percentile.displayName = u'Percentile'
        percentile.parameterType = 'Optional'
        percentile.value = None
        percentile.direction = 'Input'
        percentile.datatype = dt.format('Long')
        percentile.enabled = False

        # Minimum Neighborhood_Size
        minneighborhood = arcpy.Parameter()
        minneighborhood.name = u'Minimum Neighborhood_Size'
        minneighborhood.displayName = u'Minimum Neighborhood Size'
        minneighborhood.parameterType = 'Required'
        minneighborhood.direction = 'Input'
        minneighborhood.datatype = dt.format('Long')

        # Maximum Neighborhood_Size
        maxneighborhood = arcpy.Parameter()
        maxneighborhood.name = u'Maximum Neighborhood_Size'
        maxneighborhood.displayName = u'Maximum Neighborhood Size'
        maxneighborhood.parameterType = 'Required'
        maxneighborhood.direction = 'Input'
        maxneighborhood.datatype = dt.format('Long')

        # Output File Name
        out_file = arcpy.Parameter()
        out_file.name = u'Output Filename'
        out_file.displayName = u'Output Filename'
        out_file.direction = 'Output'
        out_file.datatype = dt.format('File')
        out_file.parameterType = 'Required'
        out_file.filter.list = ['png', 'pdf', 'ps', 'svg']

        return [bathy, imgfilter, percentile, minneighborhood,
                maxneighborhood, out_file]

    def updateParameters(self, parameters):
        if parameters[1].valueAsText.lower() == 'percentile':
            parameters[2].enabled = True
            parameters[2].parameterType = 'Required'
        else:
            parameters[2].enabled = False
            parameters[2].parameterType = 'Optional'

        bathy = parameters[0].valueAsText
        out = parameters[5]

        ws = arcpy.Describe(utils.get_workspace())
        ws_type = set([ws.workspaceType])
        db_types = ['LocalDatabase', 'RemoteDatabase']
        if not ws_type.intersection(db_types):
            if out.value is None and bathy is not None:
                base_name = os.path.splitext(os.path.basename(bathy))[0]
                out_name = '{}_scalecomparison.png'.format(base_name)
                out_path = makeDefaultFilename(out_name)
                out.value = out_path
        return

    def updateMessages(self, parameters):
        if not utils.SCIPY_EXISTS:
            parameters[0].setWarningMessage(
                "This tool requires that the SciPy module is "
                "installed. SciPy is included in ArcGIS 10.4 "
                "and later versions.")
        return

    def execute(self, parameters, messages):
        from scripts import scale_comparison
        scale_comparison.main(
            in_raster=parameters[0].valueAsText,
            img_filter=parameters[1].valueAsText,
            percentile=parameters[2].valueAsText,
            min_nbhs=parameters[3].valueAsText,
            max_nbhs=parameters[4].valueAsText,
            out_file=parameters[5].valueAsText)


class multiplescales(object):
    """ Calculate metrics at multiple scales. """

    def __init__(self):
        self.label = u'Calculate Metrics At Multiple Scales'
        self.canRunInBackground = False
        self.category = 'Multi-Scale Analysis'

    def getParameterInfo(self):

        # Bathymetry raster
        bathy = arcpy.Parameter()
        bathy.name = u'Bathymetry_raster'
        bathy.displayName = u'Bathymetry raster'
        bathy.parameterType = 'Required'
        bathy.direction = 'Input'
        bathy.datatype = dt.format('Raster Layer')

        # Neighborhood_Sizes
        nbh_sizes = arcpy.Parameter()
        nbh_sizes.name = u'Neighborhood_Size'
        nbh_sizes.displayName = u'Neighborhood Size'
        nbh_sizes.parameterType = 'Required'
        nbh_sizes.direction = 'Input'
        nbh_sizes.datatype = dt.format('Long')
        nbh_sizes.multiValue = True

        # Metrics to Compute
        metrics = arcpy.Parameter()
        metrics.name = u'Metrics_Computed'
        metrics.displayName = u'Metrics to Compute'
        metrics.parameterType = 'Required'
        metrics.direction = 'Input'
        metrics.datatype = dt.format('String')
        metrics.multiValue = True
        metrics.filter.list = ['Mean Depth', 'Variance', 'Standard Deviation',
                               'Interquartile Range', 'Kurtosis',
                               'Terrain Ruggedness (VRM)']

        # Output Workspace
        out_workspace = arcpy.Parameter()
        out_workspace.name = u'Output_Workspace'
        out_workspace.displayName = u'Output Workspace'
        out_workspace.parameterType = 'Required'
        out_workspace.direction = 'Input'
        out_workspace.datatype = dt.format('Workspace')

        return [bathy, nbh_sizes, metrics, out_workspace]

    def isLicensed(self):
        return True

    def updateParameters(self, parameters):
        workspace = parameters[3]

        if workspace.value is None:
            workspace.value = utils.get_workspace()
        return

    def updateMessages(self, parameters):
        stats = []
        if parameters[2].value:
            stats = parameters[2].valueAsText.split(";")

        if not utils.NETCDF4_EXISTS and ('Kurtosis' in stats or
                                         'Interquartile Range' in stats):
            parameters[2].setWarningMessage(
                "The interquartile range and kurtosis tools require "
                "the NetCDF4 Python library is installed. NetCDF4 "
                "is included in ArcGIS 10.3 and later.")

        if not utils.SCIPY_EXISTS and 'Kurtosis' in stats:
            parameters[2].setWarningMessage(
                "The kurtosis calculation requires the SciPy library "
                "is installed. SciPy is included in ArcGIS 10.4 and "
                "later versions.")
        return

    def execute(self, parameters, messages):
        from scripts import depth_statistics
        from scripts import ruggedness

        nbh_lst = parameters[1].valueAsText.split(";")
        metrics_lst = parameters[2].valueAsText.replace("'", '').split(";")
        stats_set = set(['Mean Depth', 'Standard Deviation', 'Variance',
                         'Interquartile Range', 'Kurtosis'])
        vrm_set = set(['Terrain Ruggedness (VRM)'])
        in_base = os.path.splitext(
            os.path.basename(parameters[0].valueAsText))[0]
        for each in nbh_lst:
            utils.msg("Computing metrics for neighborhood"
                      " size {}...".format(each))
            if stats_set.intersection(metrics_lst):
                depth_statistics.main(in_raster=parameters[0].valueAsText,
                                      neighborhood_size=each,
                                      out_workspace=parameters[3].valueAsText,
                                      out_stats_raw=parameters[2].valueAsText)
            if vrm_set.intersection(metrics_lst):
                n_label = "{:03d}".format(int(each))
                out_file = "{0}\\{1}_vrm{2}.tif".format(
                    parameters[3].valueAsText, in_base, n_label)
                ruggedness.main(in_raster=parameters[0].valueAsText,
                                neighborhood_size=each, out_raster=out_file)
        return
